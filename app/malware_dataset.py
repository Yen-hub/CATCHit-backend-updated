import json
import os
from pathlib import Path
from datetime import datetime

class MalwareDataset:
    def __init__(self):
        self.dataset_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'data')
        self.signatures_file = os.path.join(self.dataset_dir, 'signatures.json')
        self.patterns_file = os.path.join(self.dataset_dir, 'patterns.json')
        self.characteristics_file = os.path.join(self.dataset_dir, 'characteristics.json')
        
        # Create data directory if it doesn't exist
        os.makedirs(self.dataset_dir, exist_ok=True)
        
        # Initialize dataset files if they don't exist
        self._init_dataset_files()
        
        # Load datasets
        self.signatures = self._load_json(self.signatures_file)
        self.patterns = self._load_json(self.patterns_file)
        self.characteristics = self._load_json(self.characteristics_file)

    def _init_dataset_files(self):
        """Initialize dataset files with default data if they don't exist."""
        if not os.path.exists(self.signatures_file):
            self._save_json(self.signatures_file, {
                "metadata": {
                    "last_updated": datetime.now().isoformat(),
                    "version": "1.0.0"
                },
                "file_signatures": {
                    # Known malware samples (MD5 hashes)
                    "44d88612fea8a8f36de82e1278abb02f": {
                        "name": "Eicar Test File",
                        "type": "test",
                        "severity": "low",
                        "description": "Standard antivirus test file"
                    },
                    "e4968ef99266df7c9a1f0637d2389dab": {
                        "name": "Wannacry Sample",
                        "type": "ransomware",
                        "severity": "critical",
                        "description": "WannaCry ransomware sample"
                    },
                    "b7d44eb613bb3c85430a7d76771bd1f3": {
                        "name": "Zeus Banking Trojan",
                        "type": "trojan",
                        "severity": "high",
                        "description": "Zeus/Zbot banking trojan sample"
                    }
                }
            })

        if not os.path.exists(self.patterns_file):
            self._save_json(self.patterns_file, {
                "metadata": {
                    "last_updated": datetime.now().isoformat(),
                    "version": "1.0.0"
                },
                "code_patterns": {
                    "powershell_execution": {
                        "patterns": [
                            r"(?i)powershell[\s-]+(enc|encode)",
                            r"(?i)powershell.*bypass.*executionpolicy",
                            r"(?i)powershell.*downloadstring"
                        ],
                        "severity": "high",
                        "description": "PowerShell execution patterns often used in malware"
                    },
                    "system_manipulation": {
                        "patterns": [
                            r"(?i)reg.*delete",
                            r"(?i)taskkill.*\/f",
                            r"(?i)netsh.*firewall.*disable"
                        ],
                        "severity": "high",
                        "description": "System manipulation attempts"
                    },
                    "data_exfiltration": {
                        "patterns": [
                            r"(?i)(ftp|http).*upload",
                            r"(?i)telegram.*bot.*api",
                            r"(?i)discord.*webhook"
                        ],
                        "severity": "high",
                        "description": "Potential data exfiltration patterns"
                    }
                },
                "file_patterns": {
                    "suspicious_extensions": {
                        "patterns": [".exe", ".scr", ".bat", ".vbs", ".ps1"],
                        "severity": "medium",
                        "description": "Potentially dangerous file extensions"
                    },
                    "obfuscation": {
                        "patterns": [
                            r"(?i)base64_decode",
                            r"(?i)chr\(\d+\)",
                            r"(?i)eval\("
                        ],
                        "severity": "high",
                        "description": "Code obfuscation patterns"
                    }
                }
            })

        if not os.path.exists(self.characteristics_file):
            self._save_json(self.characteristics_file, {
                "metadata": {
                    "last_updated": datetime.now().isoformat(),
                    "version": "1.0.0"
                },
                "pe_characteristics": {
                    "suspicious_sections": {
                        "names": ["UPX", "ASPack", "FSG", "MEW"],
                        "severity": "medium",
                        "description": "Known packer sections"
                    },
                    "suspicious_imports": {
                        "dlls": ["wininet.dll", "urlmon.dll", "shell32.dll"],
                        "functions": ["CreateRemoteThread", "VirtualAlloc", "WriteProcessMemory"],
                        "severity": "high",
                        "description": "Commonly abused Windows APIs"
                    }
                },
                "archive_characteristics": {
                    "compression_ratio": {
                        "max_ratio": 1000,
                        "severity": "high",
                        "description": "Maximum allowed compression ratio (zip bomb detection)"
                    },
                    "suspicious_paths": {
                        "patterns": ["__MACOSX/", ".DS_Store", "Thumbs.db"],
                        "severity": "low",
                        "description": "Hidden or system files in archives"
                    }
                },
                "entropy_thresholds": {
                    "executable": {
                        "threshold": 7.0,
                        "severity": "medium",
                        "description": "Maximum entropy for executable files"
                    },
                    "text": {
                        "threshold": 6.0,
                        "severity": "medium",
                        "description": "Maximum entropy for text files"
                    }
                }
            })

    def _load_json(self, file_path):
        """Load JSON data from file."""
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}

    def _save_json(self, file_path, data):
        """Save JSON data to file."""
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=4)

    def add_signature(self, file_hash, name, malware_type, severity, description):
        """Add a new malware signature."""
        self.signatures["file_signatures"][file_hash] = {
            "name": name,
            "type": malware_type,
            "severity": severity,
            "description": description
        }
        self.signatures["metadata"]["last_updated"] = datetime.now().isoformat()
        self._save_json(self.signatures_file, self.signatures)

    def add_pattern(self, category, pattern_name, patterns, severity, description):
        """Add a new malicious pattern."""
        if category not in self.patterns:
            self.patterns[category] = {}
        
        self.patterns[category][pattern_name] = {
            "patterns": patterns if isinstance(patterns, list) else [patterns],
            "severity": severity,
            "description": description
        }
        self.patterns["metadata"]["last_updated"] = datetime.now().isoformat()
        self._save_json(self.patterns_file, self.patterns)

    def get_signatures(self):
        """Get all malware signatures."""
        return self.signatures.get("file_signatures", {})

    def get_patterns(self):
        """Get all malicious patterns."""
        return {k: v for k, v in self.patterns.items() if k != "metadata"}

    def get_characteristics(self):
        """Get all malicious characteristics."""
        return {k: v for k, v in self.characteristics.items() if k != "metadata"}